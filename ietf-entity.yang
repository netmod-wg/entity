module ietf-entity {

  /************
   NOTES:
     allow NMS to populate config
     server will use config to populate operational with configed
     values and then populate the rest of operational from
     its internal code - done.

     will oper be a superset of config? yes

     will defaults be in oper? yes

     INDEXING:  need permanant handle
     current integer is arbitrary and not required to persist.
     The serialNum, aliasID (other???) do persist so how do existing
     SNMP agents bring back these mappings after a reboot.

     Suggest: make entPhyscalIndex sticky
     could use a string instead -- solves the renumbering all ACLs
     problem so a new physical entity can be added without
     renumbering the old ones

     Keep the int32 index for backward reference but
     populate the config and oper used

     entity-state-mib adds 4 leafs that could be folded in
     use if-feature to make it optional - done.

     same consensus for entity-sensor-mib - done.

     need entPhysicalContainsMapping for reverse containment
     but this can be in the main table - done.

     do not need entLogicalTable -- SNMP only so this is not
     needed in the YANG version

     contained-in and contained-by should be leaf-lists - done.

     entLastChangeTime is a timestamp
     do we need it to be date-and-time
     (type TimeStamp now) - done; date-and-time.

     entConfigChange is useful but maybe covered by
     netconf-config-change notification, or pub/sub. it is also a bad
     name, since it fires when the opstate changes...
     Issue: need to think about which notifs to define.

     entPhySensorOperStatus compared with entStateOper- overlap?


   ***********/

  yang-version 1.1;
  //namespace "urn:ietf:params:xml:ns:yang:ietf-entity";
  namespace "urn:example:ietf-entity";
  prefix ent;

  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }

  revision 2015-08-27 {
    description
      "Initial revision.";
  }

  /*
   * Features
   */

  feature entity-mib {
    description
      "This feature indicates that the device implements
       the ENTITY-MIB.";
    reference "RFC 6933: Entity MIB (Version 4)";
  }

  feature entity-config {
    description
      "Indicates that the device supports configuration of
       physical entities.";
  }

  feature entity-state {
    description
      "Indicates the ENTITY-STATE-MIB objects are supported";
    reference "RFC 4268; Entity State MIB";
  }

  feature entity-sensor {
    description
      "Indicates the ENTITY-SENSOR-MIB objects are supported";
    reference "RFC 3433; Entity Sensor MIB";
  }

  /*
   * Typedefs
   */

  typedef entity-admin-state {
    type enumeration {
      enum unknown {
        value 1;
        description
          "The resource is unable to report administrative state.";
      }
      enum locked {
        value 2;
        description
          "The resource is administratively prohibited from use.";
      }
      enum shutting-down {
        value 3;
        description
          "The resource usage is administratively limited to current
           instances of use.";
        
      }
      enum unlocked {
        value 4;
        description
          "The resource is not administratively prohibited from use.";
      }
    }
    description
      "Represents the various possible administrative states.";
    reference "RFC 4268, EntityAdminState";
  }

  typedef entity-oper-state {
    type enumeration {
      enum unknown {
        value 1;
        description
          "The resource is unable to report operational state.";
      }
      enum disabled {
        value 2;
        description
          "The resource is totally inoperable.";
      }
      enum enabled {
        value 3;
        description
          "The resource is partially or fully operable.";
      }
      enum testing {
        value 4;
        description
          "The resource is currently being tested and cannot
           therefore report whether it is operational or not.";
      }
    }
    description
      "Represents the possible values of operational states.";
    reference "RFC 4268, EntityOperState";
  }

  typedef entity-usage-state {
    type enumeration {
      enum unknown {
        value 1;
        description
          "The resource is unable to report usage state.";
      }
      enum idle {
        value 2;
        description
          "The resource is servicing no users.";
      }
      enum active {
        value 3;
        description
          "The resource is currently in use and it has sufficient
           spare capacity to provide for additional users.";
      }
      enum busy {
        value 4;
        description
          "The resource is currently in use, but it currently has
           no spare capacity to provide for additional users.";
      }
    }
    description
      "Represents the possible values of usage states.";
    reference "RFC 4268, EntityUsageState";
  }

  typedef entity-alarm-status {
    type bits {
      bit unknown {
        position 0;
        description
          "The resource is unable to report alarm state.";
      }
      bit under-repair {
        position 1;
        description
          "The resource is currently being repaired, which, depending
           on the implementation, may make the other values in this
           bit string not meaningful.";
      }
      bit critical {
        position 2;
        description
          "One or more critical alarms are active against the
           resource.";
      }
      bit major {
        position 3;
        description
          "One or more major alarms are active against the resource.";
      }
      bit minor {
        position 4;
        description
          "One or more minor alarms are active against the resource.";
      }
      bit warning {
        position 5;
        description
          "One or more warning alarms are active against the resource.
           This alarm status is not defined in X.733.";
      }
      bit indeterminate {
        position 6;
        description
          "One or more alarms of whose perceived severity cannot be
           determined are active against this resource.
           This alarm status is not defined in X.733.";
      }
    }
    description
      "Represents the possible values of alarm status.
       An Alarm [RFC3877] is a persistent indication of an error or
       warning condition.

       When no bits of this attribute are set, then no active
       alarms are known against this entity and it is not under
       repair.";
    reference "RFC 4268, EntityAlarmStatus";
  }

  typedef entity-standby-status {
    type enumeration {
      enum unknown {
        value 1;
        description
          "The resource is unable to report standby state.";
      }
      enum hot-standby {
        value 2;
        description
          "The resource is not providing service, but it will be
           immediately able to take over the role of the resource
           to be backed up, without the need for initialization
           activity, and will contain the same information as the
           resource to be backed up.";
      }
      enum cold-standby {
        value 3;
        description
          "The resource is to back up another resource, but will not
           be immediately able to take over the role of a resource
           to be backed up, and will require some initialization
           activity.";
      }
      enum providing-service {
        value 4;
        description
          "The resource is providing service.";
      }
    }
    description
      "Represents the possible values of standby status.";
    reference "RFC 4268, EntityStandbyStatus";
  }

  typedef entity-sensor-data-type {
    type enumeration {
      enum other {
        value 1;
        description
          "A measure other than those listed below.";
      }
      enum unknown {
        value 2;
        description
          "An unknown measurement, or arbitrary, relative numbers";
      }
      enum volts-AC {
        value 3;
        description
          "A measure of electric potential (alternating current).";
      }
      enum volts-DC {
        value 4;
        description
          "A measure of electric potential (direct current).";
      }
      enum amperes {
        value 5;
        description
          "A measure of electric current.";
      }
      enum watts {
        value 6;
        description
          "A measure of power.";
      }
      enum hertz {
        value 7;
        description
          "A measure of frequency.";
      }
      enum celsius {
        value 8;
        description
          "A measure of temperature.";
      }
      enum percent-RH {
        value 9;
        description
          "A measure of percent relative humidity.";
      }
      enum rpm {
        value 10;
        description
          "A measure of shaft revolutions per minute.";
      }
      enum cmm {
        value 11;
        description
          "A measure of cubic meters per minute (airflow).";
      }
      enum truth-value {
        value 12;
        description
          "Value takes { true(1), false(2) }";
      }
    }
    description
      "An object using this data type represents the Entity Sensor
       measurement data type associated with a physical sensor
       value. The actual data units are determined by examining an
       object of this type together with the associated
       entity-sensor-data-scale object.

       An object of this type SHOULD be defined together with
       objects of type entity-sensor-data-scale and
       entity-sensor-precision. These three types are used to identify
       the semantics of an object of type entity-sensor-value.";
    reference "RFC 3433, EntitySensorDataType";
  }

  typedef entity-sensor-data-scale {
    type enumeration {
      enum yocto {
        value 1;
      }
      enum zepto {
        value 2;
      }
      enum atto {
        value 3;
      }
      enum femto {
        value 4;
      }
      enum pico {
        value 5;
      }
      enum nano {
        value 6;
      }
      enum micro {
        value 7;
      }
      enum milli {
        value 8;
      }
      enum units {
        value 9;
      }
      enum kilo {
        value 10;
      }
      enum mega {
        value 11;
      }
      enum giga {
        value 12;
      }
      enum tera {
        value 13;
      }
      enum exa {
        value 14;
      }
      enum peta {
        value 15;
      }
      enum zetta {
        value 16;
      }
      enum yotta {
        value 17;
      }
    }
    reference "RFC 3433, EntitySensorDataScale";
  }

  typedef entity-sensor-precision {
    type int32 {
      range "-8 .. 9";
    }
    description
      "An object using this data type represents a sensor
       precision range.

       An object of this type SHOULD be defined together with
       objects of type entity-sensor-data-type and
       entity-sensor-data-scale.  Together, associated objects of
       these three types are used to identify the semantics of an
       object of type entity-sensor-value.

       If an object of this type contains a value in the range 1 to
       9, it represents the number of decimal places in the
       fractional part of an associated EntitySensorValue fixed-
       point number.

       If an object of this type contains a value in the range -8
       to -1, it represents the number of accurate digits in the
       associated EntitySensorValue fixed-point number.

       The value zero indicates the associated EntitySensorValue
       object is not a fixed-point number.

       Agent implementors must choose a value for the associated
       entity-sensor-precision object so that the precision and
       accuracy of the associated entity-sensor-value object is
       correctly indicated.

       For example, a physical entity representing a temperature
       sensor that can measure 0 degrees to 100 degrees C in 0.1
       degree increments, +/- 0.05 degrees, would have an
       entity-sensor-precision value of '1', an entity-sensor-data-scale
       value of 'units(9)', and an entity-sensor-value ranging from
       '0' to '1000'.  The entity-sensor-value would be interpreted
       as 'degrees C * 10'.";
    reference "RFC 3433, EntitySensorPrecision";
  }

  typedef entity-sensor-value {
    type int32 {
      range "-1000000000 .. 1000000000";
    }
    description
     "An object using this data type represents an Entity Sensor
      value.

      An object of this type SHOULD be defined together with objects
      of type entity-sensor-data-type, entity-sensor-data-scale,
      and entity-sensor-precision.  Together, associated objects of
      those three types are used to identify the semantics of an
      object of this data type.

      The semantics of an object using this data type are
      determined by the value of the associated
      entity-sensor-data-type object.

      If the associated entity-sensor-data-type object is equal to
      'voltsAC(3)', 'voltsDC(4)', 'amperes(5)', 'watts(6),
      'hertz(7)', 'celsius(8)', or 'cmm(11)', then an object of
       this type MUST contain a fixed point number ranging from
       -999,999,999 to +999,999,999.  The value -1000000000
       indicates an underflow error. The value +1000000000
       indicates an overflow error.  The entity-sensor-precision
       indicates how many fractional digits are represented in the
       associated entity-sensor-value object.

       If the associated entity-sensor-data-type object is equal to
       'percentRH(9)', then an object of this type MUST contain a
       number ranging from 0 to 100.

       If the associated entity-sensor-data-type object is equal to
       'rpm(10)', then an object of this type MUST contain a number
       ranging from -999,999,999 to +999,999,999.

       If the associated entity-sensor-data-type object is equal to
       'truthvalue(12)', then an object of this type MUST contain
       either the value 'true(1)' or the value 'false(2)'.

       If the associated entity-sensor-data-type object is equal to
       'other(1)' or unknown(2)', then an object of this type MUST
       contain a number ranging from -1000000000 to 1000000000.";
    reference "RFC 3433, EntitySensorValue";
  }

  typedef entity-sensor-status {
    type enumeration {
      enum ok {
        value 1;
        description
          "Indicates that the agent can obtain the sensor value.";
      }
      enum unavailable {
        value 2;
        description
          "Indicates that the agent presently cannot obtain the
           sensor value.";
      }
      enum nonoperational {
        value 3;
        description
          "Indicates that the agent believes the sensor is broken.
           The sensor could have a hard failure (disconnected wire),
           or a soft failure such as out-of-range, jittery, or wildly
           fluctuating readings.";
      }
    }
    description
      "An object using this data type represents the operational
       status of a physical sensor.";
    reference "RFC 3433, EntitySensorStatus";
  }

  /*
   * Identities
   */

  identity entity-physical-class {
    description
      "This identity is the base of all physical entity class identifiers.
       Used instead of the IANAPhysicalClass textual convention to identify
       different physical entity classes.";
  }


  /*
   * Operational state data nodes
   */

  container entity-state {
    config false;

    leaf last-change {
      type yang:date-and-time;
      description
        "The time the '/entity-state/physical-entity' list changed.";
    }

    list physical-entity {
      key name;
      description
        "List of physical entities";
      reference "RFC 6933: entPhysicalEntry";

      leaf name {
        type string;
        description
          "Administrative name assigned to this physical entity.
           No restrictions apply. Not required to be the same
           as entPhysicalName.";
      }

      leaf class {
        type identityref {
          base entity-physical-class;
        }
        reference "RFC 6933: entPhysicalClass";
        // this is the iana-physical-class enum in the MIB
        // combined with vendor-type
        // The idea is that vendors can "subclass" any of the
        // IANA-defined values, derive directly from
        // entity-physical-class.
      }

      leaf physical-index {
        if-feature entity-mib;
        type int32 {
          range "1..2147483647";
        }
        description
          "The entPhysicalIndex for the entPhysicalEntry represented
           by this list entry.";
        reference "RFC 6933: entPhysicalIndex";
      }

      leaf description {
        type string;
        reference "RFC 6933: entPhysicalDescr";
        // read-only in MIB
      }

      leaf-list contained-in {
        type leafref {
          path "../../physical-entity/name";
        }
        reference "RFC 6933: entPhysicalContainedIn";
        // read-only in MIB
        // only a leaf in MIB
      }

      leaf-list contains-child {
        type leafref {
          path "../../physical-entity/name";
        }
        reference "RFC 6933: entPhysicalChildIndex";
        // read-only INDEX in MIB
        // should this be 'name' string instead of integer?
        // multiple entPhysicalContainsEntry instances in MIB
      }

      leaf parent-rel-pos {
        type int32 {
          range "0 .. 2147483647";
        }
        reference "RFC 6933: entPhysicalParentRelPos";
        // read-only in MIB
      }

      leaf hardware-rev {
        type string;
        reference "RFC 6933: entPhysicalHardwareRev";
        // read-only in MIB
      }

      leaf firmware-rev {
        type string;
        reference "RFC 6933: entPhysicalFirmwareRev";
        // read-only in MIB
      }

      leaf software-rev {
        type string;
        reference "RFC 6933: entPhysicalSoftwareRev";
        // read-only in MIB
      }

      leaf serial-num {
        type string;
        reference "RFC 6933: entPhysicalSerialNum";
        // read-write in MIB
        // write access not required if NV-storage not provided
      }

      leaf mfg-name {
        type string;
        reference "RFC 6933: entPhysicalMfgName";
        // read-only in MIB
      }

      leaf model-name {
        type string;
        reference "RFC 6933: entPhysicalModelName";
        // read-only in MIB
      }

      leaf alias {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAlias";
        // read-write in MIB
        // agent must retain the value set
      }

      leaf asset-id {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAssetID";
        // read-write in MIB
        // agent must retain the value set but not required
        // if is-fru is false
      }

      leaf is-fru {
        type boolean;
        reference "RFC 6933: entPhysicalIsFRU";
        // read-only in MIB
        // TruthValue is SYNTAX INTEGER { true(1), false(2) }
      }

      leaf mfg-date {
        type yang:date-and-time;
        reference "RFC 6933: entPhysicalMfgDate";
        // read-only in MIB
        // DateAndTime is SYNTAX OCTET STRING (SIZE (8 | 11))
      }

      leaf-list uri {
        type inet:uri;
        description
          "Each URI is in a separate leaf-list instance instead
           of a white-space delimited string of URIs";
        reference "RFC 6933: entPhysicalUris";
        // read-write in MIB (SYNTAX OCTET STRING)
      }

      leaf uuid {
        type yang:uuid;
        reference "RFC 6933: entPhysicalUUID";
        // read-only in MIB
        // SYNTAX OCTET STRING (SIZE (0|16))
      }

      leaf state-last-changed {
        if-feature entity-state;
        type yang:date-and-time;
        reference "RFC 4268, entStateLastChanged";
        // read-only in MIB
      }

      leaf admin-state {
        if-feature entity-state;
        type entity-admin-state;
        reference "RFC 4268, entStateAdmin";
        // read-write in MIB
      }

      leaf oper-state {
        if-feature entity-state;
        type entity-oper-state;
        config false;
        reference "RFC 4268, entStateOper";
        // read-only in MIB
      }

      leaf usage-state {
        if-feature entity-state;
        type entity-usage-state;
        config false;
        reference "RFC 4268, entStateUsage";
        // read-only in MIB
      }

      leaf alarm-status {
        if-feature entity-state;
        type entity-alarm-status;
        config false;
        reference "RFC 4268, entStateAlarm";
        // read-only in MIB
      }

      leaf standby-status {
        if-feature entity-state;
        type entity-standby-status;
        config false;
        reference "RFC 4268, entStateStandby";
        // read-only in MIB
      }

      container sensor-data {
        when 'derived-from(../class, "iana-entity", "sensor")';
        if-feature entity-sensor;

        leaf data-type {
          type entity-sensor-data-type;
          reference "RFC 3433, entPhySensorType";
          // read-only in MIB
        }

        leaf data-scale {
          type entity-sensor-data-scale;
          reference "RFC 3433, entPhySensorScale";
          // read-only in MIB
        }

        leaf precision {
          type entity-sensor-precision;
          reference "RFC 3433, entPhySensorScale";
          // read-only in MIB
        }

        leaf value {
          type entity-sensor-value;
          reference "RFC 3433, entPhySensorScale";
          // read-only in MIB
        }

        leaf oper-status {
          type entity-sensor-status;
          reference "RFC 3433, entPhySensorOperStatus";
          // read-only in MIB
        }

        leaf sensor-units-display {
          type string;
          reference "RFC 3433, entPhySensorUnitsDisplay";
          // read-only in MIB
        }

        leaf value-timestamp {
          type yang:date-and-time;
          reference "RFC 3433, entPhySensorValueTimeStamp";
          // read-only in MIB
        }

        leaf value-update-rate {
          type uint32;
          units "milliseconds";
          reference "RFC 3433, entPhySensorValueUpdateRate";
          // read-only in MIB
        }
      }

    }
  }

  /*
   * Configuration data nodes
   */

  container entity {
    if-feature entity-config;

    list physical-entity {
      key name;
      description
        "List of configurated data for physical entities.";

      leaf name {
        type string;
      }

      leaf serial-num {
        type string;
        reference "RFC 6933: entPhysicalSerialNum";
      }

      leaf alias {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAlias";
      }

      leaf asset-id {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAssetID";
      }

      leaf-list uri {
        type inet:uri;
        reference "RFC 6933: entPhysicalUris";
      }

      leaf admin-state {
        if-feature entity-state;
        type entity-admin-state;
        reference "RFC 4268, entStateAdmin";
        // read-write in MIB
      }

    }
  }

  /*
   * Notifications
   */

  notification ent-config-change {
    reference "RFC 6933, entConfigChange";
  }

  notification ent-state-oper-enabled {
    if-feature entity-state;
    leaf name {
      type leafref {
        path "/entity-state/physical-entity/name";
      }
    }
    leaf admin-state {
      type leafref {
        path "/entity-state/physical-entity/admin-state";
      }
    }
    leaf alarm-status {
      type leafref {
        path "/entity-state/physical-entity/alarm-status";
      }
    }
    reference "RFC 4268, entStateOperEnabled";
  }

  notification ent-state-oper-disabled {
    if-feature entity-state;
    leaf name {
      type leafref {
        path "/entity-state/physical-entity/name";
      }
    }
    leaf admin-state {
      type leafref {
        path "/entity-state/physical-entity/admin-state";
      }
    }
    leaf alarm-status {
      type leafref {
        path "/entity-state/physical-entity/alarm-status";
      }
    }
    reference "RFC 4268, entStateOperDisabled";
  }

}
