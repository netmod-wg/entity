module ietf-entity {

  /************
   NOTES:
     allow NMS to populate config
     server will use config to populate operational with configed
     values and then populate the rest of operational from
     its internal code - done.

     will oper be a superset of config? yes

     will defaults be in oper? yes

     INDEXING:  need permanant handle
     current integer is arbitrary and not required to persist.
     The serialNum, aliasID (other???) do persist so how do existing
     SNMP agents bring back these mappings after a reboot.

     Suggest: make entPhyscalIndex sticky
     could use a string instead -- solves the renumbering all ACLs
     problem so a new physical entity can be added without
     renumbering the old ones

     Keep the int32 index for backward reference but
     populate the config and oper used

     entity-state-mib adds 4 leafs that could be folded in
     use if-feature to make it optional - done.

     same consensus for entity-sensor-mib - done.

     need entPhysicalContainsMapping for reverse containment
     but this can be in the main table - done.

     do not need entLogicalTable -- SNMP only so this is not
     needed in the YANG version

     contained-in and contained-by should be leaf-lists - done.

     entLastChangeTime is a timestamp
     do we need it to be date-and-time
     (type TimeStamp now) - done; date-and-time.

     entConfigChange is useful but maybe covered by
     netconf-config-change notification, or pub/sub. it is also a bad
     name, since it fires when the opstate changes...
     Issue: need to think about which notifs to define.

     entPhySensorOperStatus compared with entStateOper- overlap?


   ***********/

  yang-version 1.1;
  //namespace "urn:ietf:params:xml:ns:yang:ietf-entity";
  namespace "urn:example:ietf-entity";
  prefix ent;

  import ietf-inet-types {
    prefix inet;
  }
  import ietf-yang-types {
    prefix yang;
  }

  revision 2015-08-27 {
    description
      "Initial revision.";
  }

  /*
   * Features
   */

  feature entity-mib {
    description
      "This feature indicates that the device implements
       the ENTITY-MIB.";
    reference "RFC 6933: Entity MIB (Version 4)";
  }

  feature entity-config {
    description
      "Indicates that the device supports configuration of
       physical entities.";
  }

  feature entity-state {
    description
      "Indicates the ENTITY-STATE-MIB objects are supported";
    reference "RFC 4268; Entity State MIB";
  }

  feature entity-sensor {
    description
      "Indicates the ENTITY-SENSOR-MIB objects are supported";
    reference "RFC 3433; Entity Sensor MIB";
  }

  /*
   * Typedefs
   */

  typedef entity-admin-state {
    type enumeration {
      enum unknown {
        value 1;
      }
      enum locked {
        value 2;
      }
      enum shutting-down {
        value 3;
      }
      enum unlocked {
        value 4;
      }
    }
    reference "RFC 4268, EntityAdminState";
  }

  typedef entity-oper-state {
    type enumeration {
      enum unknown {
        value 1;
      }
      enum disabled {
        value 2;
      }
      enum enabled {
        value 3;
      }
      enum testing {
        value 4;
      }
    }
    reference "RFC 4268, EntityOperState";
  }

  typedef entity-usage-state {
    type enumeration {
      enum unknown {
        value 1;
      }
      enum active {
        value 2;
      }
      enum idle {
        value 3;
      }
      enum busy {
        value 4;
      }
    }
    reference "RFC 4268, EntityUsageState";
  }

  typedef entity-alarm-status {
    type enumeration {
      enum unknown {
        value 0;
      }
      enum under-repair {
        value 1;
      }
      enum critical {
        value 2;
      }
      enum major {
        value 3;
      }
      enum minor {
        value 4;
      }
      enum warning {
        value 5;
      }
      enum indeterminate {
        value 6;
      }
    }
    reference "RFC 4268, EntityAlarmStatus";
  }

  typedef entity-standby-status {
    type enumeration {
      enum unknown {
        value 1;
      }
      enum hot-standby {
        value 2;
      }
      enum cold-standby {
        value 3;
      }
      enum providing-service {
        value 4;
      }
    }
    reference "RFC 4268, EntityStandbyStatus";
  }

  typedef entity-sensor-data-type {
    type enumeration {
      enum other {
        value 1;
      }
      enum unknown {
        value 2;
      }
      enum volts-AC {
        value 3;
      }
      enum volts-DC {
        value 4;
      }
      enum amperes {
        value 5;
      }
      enum watts {
        value 6;
      }
      enum hertz {
        value 7;
      }
      enum celsius {
        value 8;
      }
      enum percent-RH {
        value 9;
      }
      enum rpm {
        value 10;
      }
      enum cmm {
        value 11;
      }
      enum truth-value {
        value 12;
      }
    }
    reference "RFC 3433, EntitySensorDataType";
  }

  typedef entity-sensor-data-scale {
    type enumeration {
      enum yocto {
        value 1;
      }
      enum zepto {
        value 2;
      }
      enum atto {
        value 3;
      }
      enum femto {
        value 4;
      }
      enum pico {
        value 5;
      }
      enum nano {
        value 6;
      }
      enum micro {
        value 7;
      }
      enum milli {
        value 8;
      }
      enum units {
        value 9;
      }
      enum kilo {
        value 10;
      }
      enum mega {
        value 11;
      }
      enum giga {
        value 12;
      }
      enum tera {
        value 13;
      }
      enum exa {
        value 14;
      }
      enum peta {
        value 15;
      }
      enum zetta {
        value 16;
      }
      enum yotta {
        value 17;
      }
    }
    reference "RFC 3433, EntitySensorDataScale";
  }

  typedef entity-sensor-precision {
    type int32 {
      range "-8 .. 9";
    }
    reference "RFC 3433, EntitySensorPrecision";
  }

  typedef entity-sensor-value {
    type int32 {
      range "-1000000000 .. 1000000000";
    }
    reference "RFC 3433, EntitySensorValue";
  }

  typedef entity-sensor-status {
    type enumeration {
      enum ok {
        value 1;
      }
      enum unavailable {
        value 2;
      }
      enum nonoperational {
        value 3;
      }
    }
    reference "RFC 3433, EntitySensorStatus";
  }

  /*
   * Identities
   */

  identity entity-physical-class;

  /*
   * Operational state data nodes
   */

  container entity-state {
    config false;

    leaf last-change {
      type yang:date-and-time;
      description
        "The time the '/entity-state/physical-entity' list changed.";
    }

    list physical-entity {
      key name;
      description
        "List of physical entities";
      reference "RFC 6933: entPhysicalEntry";

      leaf name {
        type string;
        description
          "Administrative name assigned to this physical entity.
           No restrictions apply. Not required to be the same
           as entPhysicalName.";
      }

      leaf class {
        type identityref {
          base entity-physical-class;
        }
        reference "RFC 6933: entPhysicalClass";
        // this is the iana-physical-class enum in the MIB
        // combined with vendor-type
        // The idea is that vendors can "subclass" any of the
        // IANA-defined values, derive directly from
        // entity-physical-class.
      }

      leaf physical-index {
        if-feature entity-mib;
        type int32 {
          range "1..2147483647";
        }
        description
          "The entPhysicalIndex for the entPhysicalEntry represented
           by this list entry.";
        reference "RFC 6933: entPhysicalIndex";
      }

      leaf description {
        type string;
        reference "RFC 6933: entPhysicalDescr";
        // read-only in MIB
      }

      leaf-list contained-in {
        type leafref {
          path "../../physical-entity/name";
        }
        reference "RFC 6933: entPhysicalContainedIn";
        // read-only in MIB
        // only a leaf in MIB
      }

      leaf-list contains-child {
        type leafref {
          path "../../physical-entity/name";
        }
        reference "RFC 6933: entPhysicalChildIndex";
        // read-only INDEX in MIB
        // should this be 'name' string instead of integer?
        // multiple entPhysicalContainsEntry instances in MIB
      }

      leaf parent-rel-pos {
        type int32 {
          range "0 .. 2147483647";
        }
        reference "RFC 6933: entPhysicalParentRelPos";
        // read-only in MIB
      }

      leaf hardware-rev {
        type string;
        reference "RFC 6933: entPhysicalHardwareRev";
        // read-only in MIB
      }

      leaf firmware-rev {
        type string;
        reference "RFC 6933: entPhysicalFirmwareRev";
        // read-only in MIB
      }

      leaf software-rev {
        type string;
        reference "RFC 6933: entPhysicalSoftwareRev";
        // read-only in MIB
      }

      leaf serial-num {
        type string;
        reference "RFC 6933: entPhysicalSerialNum";
        // read-write in MIB
        // write access not required if NV-storage not provided
      }

      leaf mfg-name {
        type string;
        reference "RFC 6933: entPhysicalMfgName";
        // read-only in MIB
      }

      leaf model-name {
        type string;
        reference "RFC 6933: entPhysicalModelName";
        // read-only in MIB
      }

      leaf alias {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAlias";
        // read-write in MIB
        // agent must retain the value set
      }

      leaf asset-id {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAssetID";
        // read-write in MIB
        // agent must retain the value set but not required
        // if is-fru is false
      }

      leaf is-fru {
        type boolean;
        reference "RFC 6933: entPhysicalIsFRU";
        // read-only in MIB
        // TruthValue is SYNTAX INTEGER { true(1), false(2) }
      }

      leaf mfg-date {
        type yang:date-and-time;
        reference "RFC 6933: entPhysicalMfgDate";
        // read-only in MIB
        // DateAndTime is SYNTAX OCTET STRING (SIZE (8 | 11))
      }

      leaf-list uri {
        type inet:uri;
        description
          "Each URI is in a separate leaf-list instance instead
           of a white-space delimited string of URIs";
        reference "RFC 6933: entPhysicalUris";
        // read-write in MIB (SYNTAX OCTET STRING)
      }

      leaf uuid {
        type yang:uuid;
        reference "RFC 6933: entPhysicalUUID";
        // read-only in MIB
        // SYNTAX OCTET STRING (SIZE (0|16))
      }

      leaf last-changed {
        if-feature entity-state;
        type yang:date-and-time;
        reference "RFC 4268, entStateLastChanged";
        // read-only in MIB
        // DateAndTime is SYNTAX OCTET STRING (SIZE (8 | 11))
      }

      leaf admin-state {
        if-feature entity-state;
        type entity-admin-state;
        reference "RFC 4268, entStateAdmin";
        // read-write in MIB
      }

      leaf oper-state {
        if-feature entity-state;
        type entity-oper-state;
        config false;
        reference "RFC 4268, entStateOper";
        // read-only in MIB
      }

      leaf usage-state {
        if-feature entity-state;
        type entity-usage-state;
        config false;
        reference "RFC 4268, entStateUsage";
        // read-only in MIB
      }

      leaf alarm-status {
        if-feature entity-state;
        type entity-alarm-status;
        config false;
        reference "RFC 4268, entStateAlarm";
        // read-only in MIB
      }

      leaf standby-status {
        if-feature entity-state;
        type entity-standby-status;
        config false;
        reference "RFC 4268, entStateStandby";
        // read-only in MIB
      }

      container sensor-data {
        when 'derived-from(../class, "iana-entity", "sensor")';
        if-feature entity-sensor;

        leaf data-type {
          type entity-sensor-data-type;
          reference "RFC 3433, entPhySensorType";
          // read-only in MIB
        }

        leaf data-scale {
          type entity-sensor-data-scale;
          reference "RFC 3433, entPhySensorScale";
          // read-only in MIB
        }

        leaf precision {
          type entity-sensor-precision;
          reference "RFC 3433, entPhySensorScale";
          // read-only in MIB
        }

        leaf value {
          type entity-sensor-value;
          reference "RFC 3433, entPhySensorScale";
          // read-only in MIB
        }

        leaf oper-status {
          type entity-sensor-status;
          reference "RFC 3433, entPhySensorOperStatus";
          // read-only in MIB
        }

        leaf sensor-units-display {
          type string;
          reference "RFC 3433, entPhySensorUnitsDisplay";
          // read-only in MIB
        }

        leaf value-timestamp {
          type yang:date-and-time;
          reference "RFC 3433, entPhySensorValueTimeStamp";
          // read-only in MIB
        }

        leaf value-update-rate {
          type uint32;
          units "milliseconds";
          reference "RFC 3433, entPhySensorValueUpdateRate";
          // read-only in MIB
        }
      }

    }
  }

  /*
   * Configuration data nodes
   */

  container entity {
    if-feature entity-config;

    list physical-entity {
      key name;
      description
        "List of configurated data for physical entities.";

      leaf name {
        type string;
      }

      leaf serial-num {
        type string;
        reference "RFC 6933: entPhysicalSerialNum";
      }

      leaf alias {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAlias";
      }

      leaf asset-id {
        type string {
          length "0 .. 32";
        }
        reference "RFC 6933: entPhysicalAssetID";
      }

      leaf-list uri {
        type inet:uri;
        reference "RFC 6933: entPhysicalUris";
      }
    }
  }

  /*
   * Notifications
   */

  notification ent-config-change {
    reference "RFC 6933, entConfigChange";
  }

  notification ent-state-oper-enabled {
    if-feature entity-state;
    leaf name {
      type leafref {
        path "/entity-state/physical-entity/name";
      }
    }
    leaf admin-state {
      type leafref {
        path "/entity-state/physical-entity/admin-state";
      }
    }
    leaf alarm-status {
      type leafref {
        path "/entity-state/physical-entity/alarm-status";
      }
    }
    reference "RFC 4268, entStateOperEnabled";
  }

  notification ent-state-oper-disabled {
    if-feature entity-state;
    leaf name {
      type leafref {
        path "/entity-state/physical-entity/name";
      }
    }
    leaf admin-state {
      type leafref {
        path "/entity-state/physical-entity/admin-state";
      }
    }
    leaf alarm-status {
      type leafref {
        path "/entity-state/physical-entity/alarm-status";
      }
    }
    reference "RFC 4268, entStateOperDisabled";
  }

}
